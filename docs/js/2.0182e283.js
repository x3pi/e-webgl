(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[2],{"77e5":function(e,a,t){"use strict";t.r(a);var r=t("7a23");const n={class:""};function o(e,a,t,o,i,c){const s=Object(r["B"])("w01");return Object(r["u"])(),Object(r["e"])("div",n,[Object(r["h"])(s)])}const i=Object(r["I"])("data-v-3c289491");Object(r["x"])("data-v-3c289491");const c={class:"viewer"},s=Object(r["h"])("canvas",{id:"canvasView"},null,-1);Object(r["v"])();const d=i(((e,a,t,n,o,i)=>(Object(r["u"])(),Object(r["e"])("div",c,[s]))));t("cfc3"),t("ace4");var v={name:"Landing",data(){return{}},methods:{init:function(){var e="#version 300 es\n\n      // an attribute is an input (in) to a vertex shader.\n      // It will receive data from a buffer\n      in vec4 a_position;\n\n      // all shaders have a main function\n      void main() {\n\n        // gl_Position is a special variable a vertex shader\n        // is responsible for setting\n        gl_Position = a_position;\n      }\n    ",a='#version 300 es\n\n      // fragment shaders don\'t have a default precision so we need\n      // to pick one. highp is a good default. It means "high precision"\n      precision highp float;\n\n      // we need to declare an output for the fragment shader\n      out vec4 outColor;\n\n      void main() {\n        // Just set the output to a constant redish-purple\n        outColor = vec4(1, 0, 0.5, 1);\n      }\n      ',t=document.querySelector("#canvasView"),r=t.getContext("webgl2");if(r){var n=this.createShader(r,r.VERTEX_SHADER,e),o=this.createShader(r,r.FRAGMENT_SHADER,a),i=this.createProgram(r,n,o),c=r.getAttribLocation(i,"a_position"),s=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,s);var d=[-1,0,0,.5,.7,0];r.bufferData(r.ARRAY_BUFFER,new Float32Array(d),r.STATIC_DRAW);var v=r.createVertexArray();r.bindVertexArray(v),r.enableVertexAttribArray(c);var u=2,h=r.FLOAT,l=!1,f=0,g=0;r.vertexAttribPointer(c,u,h,l,f,g),webglUtils.resizeCanvasToDisplaySize(r.canvas),r.viewport(0,0,r.canvas.width,r.canvas.height),r.clearColor(0,0,0,0),r.clear(r.COLOR_BUFFER_BIT),r.useProgram(i),r.bindVertexArray(v);var b=r.TRIANGLES,p=(g=0,3);r.drawArrays(b,g,p)}},createShader:function(e,a,t){var r=e.createShader(a);e.shaderSource(r,t),e.compileShader(r);var n=e.getShaderParameter(r,e.COMPILE_STATUS);if(n)return r;console.log(e.getShaderInfoLog(r)),e.deleteShader(r)},createProgram:function(e,a,t){var r=e.createProgram();e.attachShader(r,a),e.attachShader(r,t),e.linkProgram(r);var n=e.getProgramParameter(r,e.LINK_STATUS);if(n)return r;console.log(e.getProgramInfoLog(r)),e.deleteProgram(r)}},mounted(){this.init()}};t("83d3");v.render=d,v.__scopeId="data-v-3c289491";var u=v,h=Object(r["i"])({components:{W01:u},name:"PageIndex"});h.render=o;a["default"]=h},"83d3":function(e,a,t){"use strict";t("dfac")},dfac:function(e,a,t){}}]);