<template>
  <div id="canva">
    <canvas id="c"></canvas>
  </div>
</template>

<script>
export default {
  name: "Landing",
  data() {
    return {}
  },
  methods: {
    init: function () {
      "use strict"

      var vertexShaderSource = `#version 300 es

      // an attribute is an input (in) to a vertex shader.
      // It will receive data from a buffer
      in vec2 a_position;

      // Used to pass in the resolution of the canvas
      uniform vec2 u_resolution;

      // all shaders have a main function
      void main() {

        // convert the position from pixels to 0.0 to 1.0
        vec2 zeroToOne = a_position / u_resolution;

        // convert from 0->1 to 0->2
        vec2 zeroToTwo = zeroToOne * 2.0;

        // convert from 0->2 to -1->+1 (clipspace)
        vec2 clipSpace = zeroToTwo - 1.0;

        gl_Position = vec4(clipSpace, 0, 1);
      }
      `

      var fragmentShaderSource = `#version 300 es

      // fragment shaders don't have a default precision so we need
      // to pick one. highp is a good default. It means "high precision"
      precision highp float;

      // we need to declare an output for the fragment shader
      out vec4 outColor;

      void main() {
        // Just set the output to a constant redish-purple
        outColor = vec4(1, 0, 0.5, 1);
      }
      `

      var canvas = document.querySelector("#c")
      var gl = canvas.getContext("webgl2")
      if (!gl) {
        return
      }

      // Use our boilerplate utils to compile the shaders and link into a program
      var program = webglUtils.createProgramFromSources(gl, [
        vertexShaderSource,
        fragmentShaderSource,
      ])

      // look up where the vertex data needs to go.
      var positionAttributeLocation = gl.getAttribLocation(
        program,
        "a_position"
      )

      // look up uniform locations
      var resolutionUniformLocation = gl.getUniformLocation(
        program,
        "u_resolution"
      )

      // Create a buffer and put a single pixel space rectangle in
      // it (2 triangles)
      // Create a buffer and put three 2d clip space points in it
      var positionBuffer = gl.createBuffer()

      // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)

      var positions = [10, 20, 80, 20, 10, 30, 10, 30, 80, 20, 80, 30]
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(positions),
        gl.STATIC_DRAW
      )

      // Create a vertex array object (attribute state)
      var vao = gl.createVertexArray()

      // and make it the one we're currently working with
      gl.bindVertexArray(vao)

      // Turn on the attribute
      gl.enableVertexAttribArray(positionAttributeLocation)

      // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
      var size = 2 // 2 components per iteration
      var type = gl.FLOAT // the data is 32bit floats
      var normalize = false // don't normalize the data
      var stride = 0 // 0 = move forward size * sizeof(type) each iteration to get the next position
      var offset = 0 // start at the beginning of the buffer
      gl.vertexAttribPointer(
        positionAttributeLocation,
        size,
        type,
        normalize,
        stride,
        offset
      )

      webglUtils.resizeCanvasToDisplaySize(gl.canvas)

      // Tell WebGL how to convert from clip space to pixels
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

      // Clear the canvas
      gl.clearColor(0, 0, 0, 0)
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

      // Tell it to use our program (pair of shaders)
      gl.useProgram(program)

      // Bind the attribute/buffer set we want.
      gl.bindVertexArray(vao)

      // Pass in the canvas resolution so we can convert from
      // pixels to clipspace in the shader
      gl.uniform2f(
        resolutionUniformLocation,
        gl.canvas.width / 20,
        gl.canvas.height / 20
      )

      // draw
      var primitiveType = gl.TRIANGLES
      var offset = 0
      var count = 6
      gl.drawArrays(primitiveType, offset, count)
    },
    createShader: function (gl, type, source) {
      var shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)
      var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS)
      if (success) {
        return shader
      }

      console.log(gl.getShaderInfoLog(shader)); // eslint-disable-line
      gl.deleteShader(shader)
      return undefined
    },
    createProgram: function (gl, vertexShader, fragmentShader) {
      var program = gl.createProgram()
      gl.attachShader(program, vertexShader)
      gl.attachShader(program, fragmentShader)
      gl.linkProgram(program)
      var success = gl.getProgramParameter(program, gl.LINK_STATUS)
      if (success) {
        return program
      }

      console.log(gl.getProgramInfoLog(program)); // eslint-disable-line
      gl.deleteProgram(program)
      return undefined
    },
  },
  mounted() {
    this.init()
  },
}
</script>

<style scoped>
@import url("../css/webgl-tutorials.css");
body {
  margin: 0;
}
</style>
